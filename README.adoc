== Usage

[quote, paraphrased from https://github.com/nothings/stb]
____
The idea behind single-header file libraries is that they're easy to distribute and deploy because all the code is contained in a single file. By default, the .h files in here act as their own header files, i.e. they declare the functions contained in the file but don't actually result in any code getting compiled.

So in addition, you should select exactly one pass:[C/C++] source file that actually instantiates the code, preferably a file you're not editing frequently. This file should define a specific macro (`HH_IMPLEMENTATION`) to actually enable the function definitions. To use `hh.h`, you should have exactly one pass:[C/C++] file that doesn't include `hh.h` regularly, but instead does

[source,c]
----
#define HH_IMPLEMENTATION
#include "hh.h"
----
____

=== Prefix Stripping

By default, every exported function/macro is prefixed by `hh_` or `HH_`.
These prefixes can be omitted by supplying an additional definition before including the library:

[source,c]
----
#define HH_IMPLEMENTATION
#define HH_STRIP_PREFIXES
#include "hh.h"
----

== Reference

=== Logging

Three hierarchical logging levels are provided `HH_LOG_DBG`, `HH_LOG_MSG`, `HH_LOG_ERR`. 
They are enabled by defining `HH_LOG`.

When `HH_LOG_DBG` is enabled, both errors and info messages will be printed.
Enabling `HH_LOG_MSG` prints everything but debug statements.
`HH_LOG_ERR` emits only error messages.

[source,c]
----
#include <time.h>

#define HH_IMPLEMENTATION
#define HH_LOG HH_LOG_DBG
#include "hh.h"

int main(int argc, char* argv[]) {
    HH_DBG("Current time: %ld", (long) time(NULL));
    HH_MSG("Hello from \"%s\"!", argv[0]);
    HH_ERR("An error occurred!");
}
// outputs:
// DEBUG [demo.c:8]: Current time: 1764761604
// INFO [demo.c:9]: Hello from "./demo"!
// ERROR [demo.c:10]: An error occurred!
----

These logging macros are fully variadic, and report the call site.

If variadics alone aren't sufficient, it's possible to incrementally build the logging statement using `HH_DBG_BLOCK`, `HH_MSG_BLOCK` and `HH_ERR_BLOCK`.
Debug statements and messages are written to _stdout_, while errors are output to _stderr_.

[source,c]
----
static int values[] = { 1, 2, 3, 4, 5 };
HH_DBG_BLOCK {
    for(size_t i = 0; i < HH_ARR_LEN(values); ++i)
        printf("%d, ", values[i]);
    printf("\n");
}
// outputs:
// DEBUG [demo.c:7]: 1, 2, 3, 4, 5,
----

=== Parsing

`hh_span_t` provides easy parsing for tokens separated by whitespace or delimiters.
Calling `hh_span_next` advances to the next token, ignoring whitespace and delimiters.

Delimiters are not required at the end of lines.

[source,c]
----
static char text[] = "Hello, world!";
hh_span_t token;
hh_span_init(&token, text, ",");
int i = 0;
do {
    HH_MSG("token %d: \"%.*s\"", i++, (int) token.len, token.ptr);
} while(hh_span_next(&token));
// outputs:
// INFO [demo.c:11]: token 0: "Hello"
// INFO [demo.c:11]: token 1: "world!"
----

Spans can be directly parsed with format specifiers using `hh_span_parse` and `hh_span_parse_next`.

[source,c]
----
static char text[] = "1.57, 3.14, 6.28";
hh_span_t token;
hh_span_init(&token, text, ",");
int i = 0;
for(bool finished = false; !finished;) {
    float value;
    finished = !hh_span_parse_next(&token, "%f", &value);
    HH_MSG("token %d: %f", i++, value);
}
// outputs:
// INFO [demo.c:13]: token 0: 1.570000
// INFO [demo.c:13]: token 1: 3.140000
// INFO [demo.c:13]: token 2: 6.280000
----
